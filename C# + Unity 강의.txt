			

			*****12월 7일*****

	객체 : 메모리 안에있는 사물(가상)
	클래스 : 객체를 이루고 있는 타입 = int는 정수로 이루어진 타입
	만들고 싶은 객체 설계 >> 설계도는 클래스로 제작 >> 클래스를 통해 객체 생성

	**Ex))
	우리가 만들고 싶은 것 : 검사(RPG)
	검사의 특징들 :
	HP 100
	MP 50
	ATK 80
	EXP 0
	스킬 : 베기, 내려찍기

	검사를 만들어내기 우한 설계도 (class)
	검사class
	{
		HP 100
		MP 50
		ATK 80
		EXP 0
		베기() 
		내려찍기()
	}

	사용자 1이 검사 클래스를 선택했습니다 !
	>> 검사 class 설계도를 기반으로 
	"검사" 라는 객체가 생성됨. 
	
	이런 형태이다
__________________________________________________________________________________________________________________________

	*****12월 9일*****
	클래스를 이루는 것들
	변수 : ( int ,float, char, string )
	그룹형 변수 : ( array, list, dictionary, queue
	연산자 : ( 산술, 증감, 관계, 대입, 논리, 비트 관련 연산 )
	조건문 : ( if, switch )
	반복문 : ( for, foreach, while )
	함수 : ( 함수, 함수 오버로딩, 델리게이트, 인터페이스 )
	클래스 : ( 클래스, SOLID 원칙, 상속 )

	using 키워드 (using System;) :
	using 뭔가를 사용하겠다 라고 선언하는 키워드 .
	System 이라는 것을 사용하겠다. 라는 뜻
	using 은 언제 쓰는 것인가?


	namespace 키워드 (namespace UnityLesson_Csharp_Program) :
	클래스 간의 멤버 이름 충돌을 방지함 .

	*Ex) 네임스페이스 정의
	만약에 UnityLesson_CSharp_Program2 라는 namespace 의 클래스 등 정보를 가져와 쓰고 싶다.
	>>> UnityLesson_CSharp_Program2 라고 스크립트 최 상단에 선언해줌.

	*Ex 2) 우선순위가 차순위인 함수 호출
	UnityEngine.Physics , Unity.Physics
	두가지 중 기본적으로는 unityEngine.Physics 가 우선순위
	두 네임스페이스 모두 Raycast() 라는 함수를 포함하고 있다 .
	But 나는 Unity.Physics.Raycast() 를 쓰고싶다 
	>> 일반적으로 Raycast() 를 호출하면 >> UnityEngine.Physics.Raycast() 가 호출됨.
	using Raycast = Unity.Physics.Raycast가 호출됨


	Program class (class Program) : 
	모든 프로젝트는 처음 실행파일(.exe)을 통해 실행될 때에
	main() 함수를 실행하며
	C#에서 main함수조차도 객체지향컨셉에 맞게 Program이라는 클래스 안에 선언되어있음 .


	static 키워드 : (static ~~~ main ~~)
	static (정적) 은 dynamic (동적) 의 반대 개념 키워드
	static 은 상황, 조건에 따라 메모리에 할당할 수 없는 성질
	dynamic 은 은 상황, 조건에 따라 메모리에 할당할 수 없는 성질
	main 함수는 static으로 정의되었으므로 하나만 존재할 수 있다 .
	만약 class에 static이 붙으면
	그에 딸린 모든 변수나 함수도 static 이어야 함.


	void 자료형 (~~void ~~) :
	void : 반환값이 없다.
	입력 >> 기능수행 >> 출력
	void 를 반환하는 함수는 : 입력(없을수도 있음) >> 기능수행 


	args (~~~~args):
	arguments 인자, 인수
	함수에서 받을 입력
	표기방법은 함수 이름 뒤에 괄호열고 " 자료형 " " 인자이름 " 형태로 써준다


	bit = 한자리 이진수 ( 0과 1, 정보처리의 최소단위 )
	1 Byte = 8 bit ( CPU 데이터 처리 최소단위 )
	4 Byte = 8 bit * 4 = 32 bit
	4 Byte로 표현할 수 있는 숫자의 범위 >> 2^32

	int // 정수형 , 4 Byte - 2147483648~2147483647
	float // 실수형 . 4 byte
	bool // 논리형 ( 참과 거짓 ) , 1 Byte
	char // 문자형 , 2 Byte
	string // 문자열 , 문자갯수 * 2 Byte

____________________________________________________________________________________________________________________________


	*****12월 14일*****



            if 문 : 만약 소괄호 안의 내용이 참이면 중괄호 안의 내용을 실행한다.

            if( 조건 1 )
            {
                조건 1이 참일때 실행할 내용
            }
            else if ( 조건 2 )
            {
                조건 1이 거짓이고 조건 2가 참일때 실행할 내용
            }
            else if ( 조건 3 )
            { 
                조건1, 조건 2가 거짓이고 조건 3이 참일때 실행할 내용
            }
            else
            {
                조건1, 조건2, 조건3이 모두 거짓일 경우 실행할 내용
            }
        
	보통 if문 조건문의 변수는 bool타입으로 선언한다.
	Ex ) static bool condition 1;





	*클래스 제작 순서* 
	1. 객체설정 : 
	Ex ) 사람
	
	2. 추상화 : 
	Ex ) 사람은 나이와 키, 남자인지 여자인지와 
	성별문자, 이름이 있다 .

	3. 클래스화 ( 설계도 제작 ) :
 	추상화에서 각 특징과 요소들의 형태를 정의
	변수 "나이"는 정수형이다.
	변수 "키"는 실수형이다.
	변수 "여자인가?"는 논리형이다.
	변수 "성별문자"는 문자형이다.
	변수 "이름"은 문자열형이다.

	4. 객체화 :
	설계도로 객체를 제작
	*객체 : 클래스로 만들어진 사물 / 개념
	
	5. 인스턴스화 :
	클래스로 생성한 객체를 메모리에 할당
	*인스턴스 : 메모리에 할당된 객체





	*소스 코딩 시 공통 규칙*
	Camel case :
	class, function, namespace 등은 대문자로 시작.
	변수는 소문자로 시작.
	단어가 바뀔때 첫 문자는 대문자로 한다.
	
	코딩 시 줄임말은 되도록 사용하지 않는다.
	이름을 보았을때 어떤 기능이나 목적인지 알 수 있도록 선정한다.
	( 팀작업 시 남들이 알수 있도록 )

	애매하거나 복잡한 내용이 있으면 주석을 달아준다.
	클래스 마다 or 함수 위, 옆 등등






	 class Program
    {
        static void Main(string[] args)
        {
            // 객체 생성
            // new 키워드
            new AA(); // 생성자 : 클래스 이름과 같은 함수, 객체를 생성함

            // 인스턴스화
            // 메모리 공간에 객체를 할당시킨다.
            // AA 타입의 변수 a 에 new AA() 로 생성된 객체가 할당 되었다.
            // 이제 new AA로 생성된 객체가 필요할때마다 
            // 변수 a 를 통해 new AA() 로 생선된 객체에 접근 가능해짐.
            // 그리고 이렇게 되었을때 new AA()로 생성된 객체를 인스턴스 라고 한다.
            AA a = new AA();
            int i = 13;
        }
    }
    //클래스 (설계도)
    public class AA
    {
        // 생성자
        AA()
        {

        }
        //소멸자
        ~AA()
        {

        }

    }



	*접근제한자*
        	위치 : 자료형 앞
        	아무것도 안써져있면 기본적으로 private
        	public, private, protected
        	public ( 공적 ) : 다른 클래스에서도 접근이 가능
        	private ( 사적 ) : 다른 클래스에서 접근이 불가능
        	protected : 상속자만 접근이 가능




	*점연산자*
	( . ) : 클래스의 멤버에 접근할때 사용, namespace 안의 클래스에 접근할때 사용.




	*객체화*
       	static void Main(string[] args)
        	{
           	 	Person person1 = new Person();
            		person1.age = 40; // 정수형은 그냥 숫자 입력
            		person1.height = 223.4f; // 실수형은 숫자 뒤에 f 추가 입력
            		person1.isFemale = false; // 논리형은 true 혹은 false 입력
            		person1.genderChar = '남'; // 문자형은 ' ' 작은 따옴표 안에 단일 문자
            		person1.name = "김아무개"; // 문자열형은 " " 큰 따옴표 안에 다중문자

            		person1.SayAllInfo();
        
        	}

___________________________________________________________________________________________________________________________________________________________________
		
	
	*****12월 17일*****

	1. 연산자
	2. 연산자 사용을 위한 클래스
	3. 배열

	연산자 :
	수학적인 연산을 하기 위한 부호
	+, -, X, %

	FSM (유한상태머신) 예시
	플레이어에게
	귀환하기라는 기능이 있는데,
	플레이어 상태가 (FSM)

	쉬고있음 >>
	피격당한상태 = 귀환이 취소됨.
	공격중인상태

_________________________________________________________________________________________________________________________________

	
	*****12월 21일*****

	1. 함수 오버로딩
	2. 배열
	3. For Loop
	4. While Loop

	*반복문
	1. for
	2. while
	3. foreach
	4. do whlie

	*분기문
	1. if
	2. switch-case

_______________________________________________________________________________________________________________________________________________________________________________________


	*****12월 23일*****

	1. for문
	2. 디버깅
	3. Collection
	    - 동적 데이터 타입
	    - List, Dictionary, Stack, Queue

____________________________________________________________________________________________________________________________________________________________________________________


	*****12월28일*****

	Collection - Queue,Stack
	Switch-case 분기문

___________________________________________________________________________________________________________________________________________________________________________

	*****12월31일*****

	부모클래스와
	자식클래스의
	상속 ( 상속 관계 ) ,

	SOLID 원칙 ( 5가지 원칙 )
	>>>	
	// SOLID 원칙
객체지향 프로그래밍을 할떄 반드시 지켜주어야 하는 5가지 원칙

1. SRP ( Single Responsibility Principle. 단일 책임 원칙 )
한 클래스는 하나의 책임만 가져야 함 . 여러가지 기능이나 개념을 한 클래스에 다 넣으면
수정하기도 불편하고 각 클래스에 대한 확장성, 가독성이 떨어짐 .

2. OCP ( Open Close Principle , 개방폐쇄의 원칙 )
재사용 가능하고 관리하기 편한 코드를 만들기 위한 원칙 .
컴포넌트, 클래스 , 모듈 , 함수의 확장에는 열려있고, 변경에는 닫혀있어야 한다 .
>>> 레고 블록을 처음에 다양하고 정확하게 설계해서 , 레고끼리 조립했을때 다양한 작품을 
만들수 있도록 한다.
조립 도중에 레고블록이 잘 안맞는다고 해서 레고블록 자체를 자르거나 불로 녹이는 등의
행위를 해선 안된다 .

3. LSP ( The Liskov Subtituation Principle , 리스코프 치환 법칙 )
하위 타입은 기반타입으로 언제든지 교체할 수 있어야 한다 .
1) 두 객체가 똑같은 일을 수행한다
                         >>> 클래스는 하나로 만들고, 각 객체를 구분지을 수 있는 변수를 멤버로 넣는다 .

2) 기능 이름이 같고 동작은 비슷하나 약간의 차이가 있다면
                         >>>인터페이스를 구현하고 공통으로 상속받는다 .

3) 같은 기능을 가지지 않는다면
                          >>>두 객체는 각각 별개의 클래스로 구현한다 .

4) 추가적인 기능을 부여해야 할 때는
                          >>>상속을 이용한다 .

4. ISP ( Interface sergregation Principle , 인터페이스 분리 법칙 )
사용하지 않을 인터페이스는 구현하면 안되고,
하나의 일반적인 인터페이스 보다 여러개의 구체적인 인터페이스를 추구함 .
IPointerEvent라는 인터페이스보다 여러 구체적인 인터페이스(IPointerDownEvent 등) 를 만드는것이 합리적이다 .

5. DIP ( Dependency Inversion Principle , 의존성 역전의 원칙 )
Caller 호출을 하는쪽
Callee 호출을 받는쪽
Caller는 Callee의 인터페이스 함수를 호출함 . 
역할 이름만 보면 Callee는 Caller를 호출하면 원칙에 어긋나듯 보이지만,
	상황에 따라서 Callee의 정보를 Caller에게 줘야할 경우가 많기때문에
	이런 경우 Callee도 Caller의 멤버를 호출할 수 있다고 하는 원칙
	XX 카드사를 Caller, 카드 사용자를 Callee라고 했을때 ,
	XX 카드사에서 카드 사용자에게 전화를 하는것에는 문제가 없음 ( 전화를 받는 쪽의 상태를 알지 못함 )
	사용자가 XX카드사에 전화를 걸때는 무작정 걸 수가 없고, 개인정보보호나 본인확인 문제 때문에
	사용자의 신분을 확인할 수 있는 주민번호 앞자리, 계좌번호 등을 요구함.
	이때 사용자가 키패드를 눌러 개인정보를 Caller인 XX카드사에 등록해주는데,
	이 등록해주는 과정이 DIP가 적용되는 경우이다. ( 의존성이 역전된 경우 )
	함수로 따지면 
	Callee 객체 Caller.Register(주민번호, 계좌번호); 를 호출한 셈.
		












